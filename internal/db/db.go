package db

import (
	"context"
	"database/sql"
	"fmt"

	"shiro/internal/util"

	_ "github.com/go-sql-driver/mysql"
)

// DB wraps sql.DB with validation hooks.
type DB struct {
	*sql.DB
	Validate func(string) error
	Observe  func(string, error)
}

// Signature stores row count and checksum.
type Signature struct {
	Count    int64
	Checksum int64
}

// Open creates a DB connection from a DSN.
func Open(dsn string) (*DB, error) {
	db, err := sql.Open("mysql", dsn)
	if err != nil {
		return nil, err
	}
	return &DB{DB: db}, nil
}

// ExecContext runs a statement after validation.
func (d *DB) ExecContext(ctx context.Context, query string, args ...any) (sql.Result, error) {
	if err := d.validate(query); err != nil {
		return nil, err
	}
	return d.DB.ExecContext(ctx, query, args...)
}

// QueryContext runs a query after validation.
func (d *DB) QueryContext(ctx context.Context, query string, args ...any) (*sql.Rows, error) {
	if err := d.validate(query); err != nil {
		return nil, err
	}
	return d.DB.QueryContext(ctx, query, args...)
}

// QueryRowContext runs a query returning a single row.
func (d *DB) QueryRowContext(ctx context.Context, query string, args ...any) *sql.Row {
	if err := d.validate(query); err != nil {
		return d.DB.QueryRowContext(ctx, "SELECT 1 WHERE 1=0")
	}
	return d.DB.QueryRowContext(ctx, query, args...)
}

// PrepareContext prepares a statement after validation.
func (d *DB) PrepareContext(ctx context.Context, query string) (*sql.Stmt, error) {
	if err := d.validate(query); err != nil {
		return nil, err
	}
	return d.DB.PrepareContext(ctx, query)
}

// QuerySignature executes a signature query and returns count/checksum.
func (d *DB) QuerySignature(ctx context.Context, query string) (Signature, error) {
	if err := d.validate(query); err != nil {
		return Signature{}, err
	}
	row := d.DB.QueryRowContext(ctx, query)
	var sig Signature
	if err := row.Scan(&sig.Count, &sig.Checksum); err != nil {
		return Signature{}, err
	}
	return sig, nil
}

// QuerySignatureWithWarnings executes a signature query and returns count/checksum
// along with session warnings generated by that query.
func (d *DB) QuerySignatureWithWarnings(ctx context.Context, query string) (Signature, []string, error) {
	if err := d.validate(query); err != nil {
		return Signature{}, nil, err
	}
	conn, err := d.DB.Conn(ctx)
	if err != nil {
		return Signature{}, nil, err
	}
	defer util.CloseWithErr(conn, "query signature conn")

	sig, err := querySignatureOnConn(ctx, conn, query)
	if err != nil {
		return Signature{}, nil, err
	}
	warnings, warnErr := queryWarningsOnConn(ctx, conn)
	if warnErr != nil {
		util.Detailf("show warnings failed after signature query: %v", warnErr)
		return sig, nil, nil
	}
	return sig, warnings, nil
}

func querySignatureOnConn(ctx context.Context, conn *sql.Conn, query string) (Signature, error) {
	row := conn.QueryRowContext(ctx, query)
	var sig Signature
	if err := row.Scan(&sig.Count, &sig.Checksum); err != nil {
		return Signature{}, err
	}
	return sig, nil
}

func queryWarningsOnConn(ctx context.Context, conn *sql.Conn) ([]string, error) {
	rows, err := conn.QueryContext(ctx, "SHOW WARNINGS")
	if err != nil {
		return nil, err
	}
	defer util.CloseWithErr(rows, "show warnings rows")
	warnings := make([]string, 0, 4)
	for rows.Next() {
		var level string
		var code int
		var msg string
		if err := rows.Scan(&level, &code, &msg); err != nil {
			return nil, err
		}
		warnings = append(warnings, fmt.Sprintf("%s:%d:%s", level, code, msg))
	}
	return warnings, rows.Err()
}

// QueryCount runs a COUNT-style query and returns the count.
func (d *DB) QueryCount(ctx context.Context, query string) (int64, error) {
	if err := d.validate(query); err != nil {
		return 0, err
	}
	row := d.DB.QueryRowContext(ctx, query)
	var count int64
	if err := row.Scan(&count); err != nil {
		return 0, err
	}
	return count, nil
}

// QueryPlanRows executes EXPLAIN and extracts estimated rows.
func (d *DB) QueryPlanRows(ctx context.Context, query string) (float64, error) {
	if err := d.validate(query); err != nil {
		return 0, err
	}
	rows, err := d.DB.QueryContext(ctx, query)
	if err != nil {
		return 0, err
	}
	defer util.CloseWithErr(rows, "plan rows")

	cols, err := rows.Columns()
	if err != nil {
		return 0, err
	}
	if len(cols) == 0 {
		return 0, fmt.Errorf("no columns in explain result")
	}

	values := make([]sql.RawBytes, len(cols))
	scanArgs := make([]any, len(cols))
	for i := range values {
		scanArgs[i] = &values[i]
	}

	for rows.Next() {
		if err := rows.Scan(scanArgs...); err != nil {
			return 0, err
		}
		for i, name := range cols {
			if name == "estRows" || name == "rows" || name == "est_rows" {
				if len(values[i]) == 0 {
					continue
				}
				var v float64
				if _, err := fmt.Sscanf(string(values[i]), "%f", &v); err == nil {
					return v, nil
				}
			}
		}
	}
	return 0, fmt.Errorf("estRows not found in explain output")
}

func (d *DB) validate(query string) error {
	if d.Validate == nil {
		return nil
	}
	err := d.Validate(query)
	if d.Observe != nil {
		d.Observe(query, err)
	}
	return err
}
